<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>GameServerController.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">JaCoCo Aggregate Report</a> &gt; <a href="../index.html" class="el_bundle">PSP031-server</a> &gt; <a href="index.source.html" class="el_package">it.polimi.ingsw.server.controller</a> &gt; <span class="el_source">GameServerController.java</span></div><h1>GameServerController.java</h1><pre class="source lang-java linenums">package it.polimi.ingsw.server.controller;

import it.polimi.ingsw.model.*;
import it.polimi.ingsw.server.model.ServerGame;
import it.polimi.ingsw.server.model.ServerPlayer;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.Unmodifiable;
import org.jetbrains.annotations.VisibleForTesting;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/**
 * Actual {@link it.polimi.ingsw.controller.GameController} server implementation which all network controllers
 * delegate to
 * &lt;p&gt;
 * This implements all the {@link it.polimi.ingsw.controller.GameController} interface methods, but with an overload
 * which is the instance of {@link ServerPlayer} executing the method
 *
 * @see it.polimi.ingsw.controller.LobbyController
 */
@SuppressWarnings({ &quot;FieldCanBeLocal&quot;, &quot;unused&quot; })
public class GameServerController {
<span class="fc" id="L32">    private static final Logger LOGGER = LoggerFactory.getLogger(GameServerController.class);</span>

    /** Reference to the game, protected by a lock */
    private final LockProtected&lt;ServerGame&gt; game;

    /** Executes the {@link #endGameFuture} */
    private final ScheduledExecutorService executor;

    /** Future that ends the game if less than 2 players are connected */
    private volatile @Nullable ScheduledFuture&lt;?&gt; endGameFuture;

    /**
     * Timeout after which a game which is suspended (aka it does not have enough players
     * to go on) is terminated
     */
    private final Duration suspendedGameTimeout;

    public GameServerController(LockProtected&lt;ServerGame&gt; game) {
<span class="fc" id="L50">        this(game, GameView.SUSPENDED_GAME_TIMEOUT);</span>
<span class="fc" id="L51">    }</span>

    @VisibleForTesting
<span class="fc" id="L54">    public GameServerController(LockProtected&lt;ServerGame&gt; game, Duration suspendedGameTimeout) {</span>
<span class="fc" id="L55">        this.game = game;</span>
<span class="fc" id="L56">        this.suspendedGameTimeout = suspendedGameTimeout;</span>
<span class="fc" id="L57">        this.executor = Executors.newSingleThreadScheduledExecutor(Thread.ofPlatform()</span>
<span class="fc" id="L58">                .name(&quot;GameServerController-endGame-thread&quot;)</span>
<span class="fc" id="L59">                .factory());</span>
<span class="fc" id="L60">    }</span>

    /**
     * Hook method called by the network controllers when a player disconnects
     * &lt;p&gt;
     * Mark the player as disconnected and suspend the game if remain only 1 player.
     * 
     * @param nick nick of the disconnecting player
     */
    public void onDisconnectPlayer(String nick) {
<span class="fc" id="L70">        try (var gameCloseable = game.use()) {</span>
<span class="fc" id="L71">            var game = gameCloseable.obj();</span>
<span class="fc" id="L72">            game.getPlayers().stream()</span>
<span class="fc" id="L73">                    .filter(p -&gt; p.getNick().equals(nick))</span>
<span class="fc" id="L74">                    .findFirst()</span>
<span class="fc" id="L75">                    .ifPresent(serverPlayer -&gt; {</span>
<span class="fc" id="L76">                        serverPlayer.connected().set(false);</span>
                        //If there is only one player, suspend the game
<span class="fc bfc" id="L78" title="All 2 branches covered.">                        if (!game.suspended().get()</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">                                &amp;&amp; game.getPlayers().stream().filter(p -&gt; p.connected().get()).count() &lt;= 1) {</span>
<span class="fc" id="L80">                            game.suspended().set(true);</span>
<span class="fc" id="L81">                            endGameFuture = executor.schedule(() -&gt; {</span>
<span class="fc" id="L82">                                LOGGER.info(&quot;Game &quot; + game.getGameID() + &quot; is over because players have disconnected&quot;);</span>
<span class="fc" id="L83">                                game.endGame().set(true);</span>
<span class="fc" id="L84">                            }, suspendedGameTimeout.toMillis(), TimeUnit.MILLISECONDS);</span>
                        }

                        // If the current player disconnects, skip his turn
<span class="fc bfc" id="L88" title="All 2 branches covered.">                        if (game.currentTurn().get().equals(serverPlayer))</span>
<span class="fc" id="L89">                            changeCurrentTurn(game);</span>
<span class="fc" id="L90">                    });</span>
        }
<span class="fc" id="L92">    }</span>

    /**
     * Hook method called by the network controllers when a player reconnects after a disconnection
     * &lt;p&gt;
     * Mark the player as connected and resume the game if it is suspended.
     * 
     * @param nick nick of the reconnecting player
     */
    public void onReconnectedPlayer(String nick) {
<span class="fc" id="L102">        try (var gameCloseable = game.use()) {</span>
<span class="fc" id="L103">            var game = gameCloseable.obj();</span>
<span class="fc" id="L104">            game.getPlayers().stream()</span>
<span class="fc" id="L105">                    .filter(p -&gt; p.getNick().equals(nick))</span>
<span class="fc" id="L106">                    .findFirst()</span>
<span class="fc" id="L107">                    .ifPresent(serverPlayer -&gt; {</span>
<span class="fc" id="L108">                        serverPlayer.connected().set(true);</span>
                        // If the current player is disconnected, we now have a new connected player that can play
<span class="fc bfc" id="L110" title="All 2 branches covered.">                        if (!game.currentTurn().get().connected().get())</span>
<span class="fc" id="L111">                            changeCurrentTurn(game);</span>

<span class="fc bfc" id="L113" title="All 4 branches covered.">                        if (game.suspended().get() &amp;&amp; game.getPlayers().stream().filter(p -&gt; p.connected().get()).count() &gt; 1) {</span>
<span class="fc" id="L114">                            game.suspended().set(false);</span>
<span class="fc" id="L115">                            Objects.requireNonNull(endGameFuture).cancel(true);</span>
                        }
<span class="fc" id="L117">                    });</span>
        }
<span class="fc" id="L119">    }</span>

    /**
     * Implementation of {@link it.polimi.ingsw.controller.GameController#makeMove(List, int)}, see
     * there for detailed docs
     *
     * @param player the player executing the method
     * @throws IllegalStateException if you can't make move at this time
     */
    public void makeMove(ServerPlayer player, List&lt;BoardCoord&gt; selected, int shelfCol) throws IllegalArgumentException {
<span class="fc" id="L129">        try (var gameCloseable = game.use()) {</span>
<span class="fc" id="L130">            var game = gameCloseable.obj();</span>

<span class="fc bfc" id="L132" title="All 2 branches covered.">            if (game.endGame().get())</span>
<span class="fc" id="L133">                throw new IllegalStateException(&quot;Game is finished&quot;);</span>

<span class="fc bfc" id="L135" title="All 2 branches covered.">            if (game.suspended().get())</span>
<span class="fc" id="L136">                throw new IllegalStateException(&quot;Game is suspended&quot;);</span>

<span class="fc bfc" id="L138" title="All 2 branches covered.">            if (!game.currentTurn().get().equals(player))</span>
<span class="fc" id="L139">                throw new IllegalArgumentException(&quot;It's not this player turn&quot;);</span>

<span class="fc" id="L141">            List&lt;Tile&gt; selectedTiles = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (!game.getBoard().checkBoardCoord(selected)</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">                    || !player.getShelfie().checkColumnSpace(shelfCol, selected.size()))</span>
<span class="fc" id="L144">                throw new IllegalArgumentException(&quot;Invalid move&quot;);</span>

            // remove tiles from board
<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (BoardCoord coord : selected) {</span>
<span class="fc" id="L148">                Property&lt;@Nullable Tile&gt; tileProp = game.getBoard().tile(coord.row(), coord.col());</span>
<span class="fc" id="L149">                selectedTiles.add(Objects.requireNonNull(tileProp.get(), &quot;Checked tile was invalid&quot;));</span>
<span class="fc" id="L150">                Property.setNullable(tileProp, null);</span>
<span class="fc" id="L151">            }</span>

            // add tiles to shelfie
<span class="fc" id="L154">            player.getShelfie().placeTiles(selectedTiles, shelfCol);</span>

<span class="fc bfc" id="L156" title="All 4 branches covered.">            if (player.getShelfie().isFull() &amp;&amp; game.firstFinisher().get() == null)</span>
<span class="fc" id="L157">                game.firstFinisher().set(player);</span>

<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (game.getBoard().needsRefill())</span>
<span class="fc" id="L160">                game.refillBoard();</span>

            // Board is empty, and we can't refill it, end the game
<span class="pc bpc" id="L163" title="1 of 4 branches missed.">            if (game.getBoard().isEmpty() &amp;&amp; game.getBagView().isEmpty()) {</span>
<span class="fc" id="L164">                game.endGame().set(true);</span>
            } else {
                // Change current turn
<span class="fc" id="L167">                changeCurrentTurn(game);</span>
            }
        }
<span class="fc" id="L170">    }</span>

    /**
     * Change the current turn to the next player, skipping disconnected players.
     * End the game if someone already finished and we reached the starting player.
     * If no player is connected, do nothing.
     * This method is called only after acquiring the lock.
     * 
     * @param game the server game
     */
    private void changeCurrentTurn(ServerGame game) {
<span class="fc" id="L181">        int nextPlayerIdx = game.getPlayers().indexOf(game.currentTurn().get());</span>
        // Try for all the remaining players
<span class="fc bfc" id="L183" title="All 2 branches covered.">        for (int i = 0; i &lt; game.getPlayers().size() - 1; i++) {</span>
<span class="fc" id="L184">            nextPlayerIdx++;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">            if (nextPlayerIdx &gt;= game.getPlayers().size())</span>
<span class="fc" id="L186">                nextPlayerIdx = 0;</span>

<span class="fc" id="L188">            var nextPlayer = game.getPlayers().get(nextPlayerIdx);</span>

            // If someone already finished, and we reached the starting player, the game is over
<span class="fc bfc" id="L191" title="All 4 branches covered.">            if (game.firstFinisher().get() != null &amp;&amp; game.getStartingPlayer().equals(nextPlayer)) {</span>
<span class="fc" id="L192">                game.endGame().set(true);</span>
<span class="fc" id="L193">                return;</span>
            }

            // Only pick a player if there's a currently connected one
<span class="fc bfc" id="L197" title="All 2 branches covered.">            if (nextPlayer.connected().get()) {</span>
<span class="fc" id="L198">                game.currentTurn().set(nextPlayer);</span>
<span class="fc" id="L199">                return;</span>
            }
        }
<span class="fc" id="L202">    }</span>

    /**
     * Implementation of {@link it.polimi.ingsw.controller.GameController#sendMessage(String, String)}}, see
     * there for detailed docs
     *
     * @param nickSendingPlayer the player executing the method
     * @throws IllegalArgumentException if message is empty or nicks are not valid
     */
    public void sendMessage(String nickSendingPlayer, String message, String nickReceivingPlayer) {
<span class="fc" id="L212">        try (var gameCloseable = game.use()) {</span>
<span class="fc" id="L213">            var game = gameCloseable.obj();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">            if (game.getPlayers().stream().noneMatch(p -&gt; p.getNick().equals(nickSendingPlayer)))</span>
<span class="fc" id="L215">                throw new IllegalArgumentException(&quot;Sending player: &quot; + nickSendingPlayer + &quot; is not valid player&quot;);</span>

<span class="fc" id="L217">            final var isForEveryone = nickReceivingPlayer.equals(UserMessage.EVERYONE_RECIPIENT);</span>
<span class="fc bfc" id="L218" title="All 4 branches covered.">            if (!isForEveryone &amp;&amp; game.getPlayers().stream().noneMatch(p -&gt; p.getNick().equals(nickReceivingPlayer)))</span>
<span class="fc" id="L219">                throw new IllegalArgumentException(&quot;Receiving player: &quot; + nickReceivingPlayer + &quot; is not valid player&quot;);</span>

<span class="fc" id="L221">            message = message.strip();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (message.isEmpty())</span>
<span class="fc" id="L223">                throw new IllegalArgumentException(&quot;No text written for message to be sent&quot;);</span>

<span class="fc" id="L225">            var ps = game.getPlayers();</span>
<span class="fc" id="L226">            game.message().set(</span>
<span class="fc bfc" id="L227" title="All 2 branches covered.">                    isForEveryone</span>
<span class="fc" id="L228">                            ? UserMessage.forEveryone(nickSendingPlayer, getPlayerColor(nickSendingPlayer, ps), message)</span>
<span class="fc" id="L229">                            : new UserMessage(</span>
<span class="fc" id="L230">                                    nickSendingPlayer, getPlayerColor(nickSendingPlayer, ps),</span>
                                    message,
<span class="fc" id="L232">                                    nickReceivingPlayer, getPlayerColor(nickReceivingPlayer, ps)));</span>
        }
<span class="fc" id="L234">    }</span>

    private String getPlayerColor(String nick, @Unmodifiable List&lt;ServerPlayer&gt; players) {
<span class="fc" id="L237">        int index = 0;</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (ServerPlayer player : players) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (player.getNick().equals(nick)) {</span>
<span class="fc" id="L240">                index = players.indexOf(player);</span>
            }
<span class="fc" id="L242">        }</span>
<span class="pc bpc" id="L243" title="3 of 5 branches missed.">        return switch (index) {</span>
<span class="fc" id="L244">            case 0 -&gt; &quot;\033[0;31m&quot;; // RED</span>
<span class="fc" id="L245">            case 1 -&gt; &quot;\033[0;32m&quot;; // GREEN</span>
<span class="nc" id="L246">            case 2 -&gt; &quot;\033[0;33m&quot;; // YELLOW</span>
<span class="nc" id="L247">            case 3 -&gt; &quot;\033[0;36m&quot;; // CYAN</span>
<span class="nc" id="L248">            default -&gt; &quot;&quot;;</span>
        };
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>
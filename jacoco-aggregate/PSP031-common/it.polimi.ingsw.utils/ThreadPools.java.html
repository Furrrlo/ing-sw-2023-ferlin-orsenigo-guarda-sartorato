<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>ThreadPools.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">JaCoCo Aggregate Report</a> &gt; <a href="../index.html" class="el_bundle">PSP031-common</a> &gt; <a href="index.source.html" class="el_package">it.polimi.ingsw.utils</a> &gt; <span class="el_source">ThreadPools.java</span></div><h1>ThreadPools.java</h1><pre class="source lang-java linenums">package it.polimi.ingsw.utils;

import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.function.Function;

/**
 * Utilities for working with thread pools
 *
 * @see java.util.concurrent.ExecutorService
 * @see java.util.concurrent.ScheduledExecutorService
 */
public class ThreadPools {

    private ThreadPools() {
    }

    /**
     * Returns a runnable which changes the name of the thread which runs it to the given one, executes the task,
     * then restores the previous name.
     * &lt;p&gt;
     * In essence, it changes the name of the running thread for the entire duration of the task
     * &lt;p&gt;
     * If the task throws an uncaught exception, the thread name will not be restored to the previous one
     * in order to be able to read it in the stack trace
     *
     * @param name new name of the thread to use for the duration of the task
     * @param task task to be executed
     * @return runnable which will execute the task with the changed thread name
     */
    public static Runnable giveNameToTask(String name, Runnable task) {
<span class="fc" id="L33">        return () -&gt; {</span>
<span class="fc" id="L34">            var th = Thread.currentThread();</span>
<span class="fc" id="L35">            var prevName = th.getName();</span>
<span class="fc" id="L36">            th.setName(name);</span>
<span class="nc" id="L37">            task.run();</span>
            // If there's an uncaught exception, keep the name
<span class="nc" id="L39">            th.setName(prevName);</span>
<span class="nc" id="L40">        };</span>
    }

    /**
     * Returns a runnable which changes the name of the thread which runs it to the given one, executes the task,
     * then restores the previous name.
     * &lt;p&gt;
     * In essence, it changes the name of the running thread for the entire duration of the task
     * &lt;p&gt;
     * If the task throws an uncaught exception, the thread name will not be restored to the previous one
     * in order to be able to read it in the stack trace
     *
     * @param name function to compute the new name of the thread to use for the duration of the task
     * @param task task to be executed
     * @return runnable which will execute the task with the changed thread name
     */
    public static Runnable giveNameToTask(Function&lt;String, String&gt; name, Runnable task) {
<span class="fc" id="L57">        return () -&gt; {</span>
<span class="fc" id="L58">            var th = Thread.currentThread();</span>
<span class="fc" id="L59">            var prevName = th.getName();</span>
<span class="fc" id="L60">            th.setName(name.apply(prevName));</span>
<span class="fc" id="L61">            task.run();</span>
            // If there's an uncaught exception, keep the name
<span class="fc" id="L63">            th.setName(prevName);</span>
<span class="fc" id="L64">        };</span>
    }

    /**
     * Waits if necessary for the computation to complete, and then
     * retrieves its result.
     * &lt;p&gt;
     * If a thread is interrupted during the call, it continues to block until the result is available,
     * and then re-interrupts the thread at the end.
     *
     * @return the computed result
     * @param &lt;T&gt; The result type returned by this Future's get method
     * @throws CancellationException if the computation was cancelled
     * @throws ExecutionException if the computation threw an exception
     */
    @SuppressWarnings(&quot;UnusedReturnValue&quot;)
    public static &lt;T&gt; T getUninterruptibly(Future&lt;T&gt; future) throws ExecutionException {
<span class="fc" id="L81">        boolean wasInterrupted = false;</span>
        try {
            while (true) {
                try {
<span class="fc" id="L85">                    return future.get();</span>
<span class="fc" id="L86">                } catch (InterruptedException e) {</span>
<span class="fc" id="L87">                    wasInterrupted = true;</span>
<span class="fc" id="L88">                }</span>
            }
        } finally {
<span class="fc bfc" id="L91" title="All 2 branches covered.">            if (wasInterrupted)</span>
<span class="fc" id="L92">                Thread.currentThread().interrupt();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>